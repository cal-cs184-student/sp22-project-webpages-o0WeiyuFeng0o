<html>

<head>
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
		integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
</head>

<body class="py-5">
	<h2 class="text-center mb-5">Project 2 - <span class="inline text-danger">Mesh Edit</span></h2>
	<div class="container">
		<div class="row">
			<!-- left margin -->
			<div class="col-2 m-0 p-0"></div>
			<div class="col-8 p-0 m-0">
				<!-- Overview -->
				<div>
					<h4 class=""><u> Overview </u></h4>
					<p> In the assignment section 1, I learned how to manipulate points to draw Bezier Curves and how to draw Bezier Surfaces based on Bezier Curves with Casteljau's algorithm. In the assignment section 2, I learned how to create a mesh editor by implementing edge flip and edge split algorithms based on Half-edge data structure. On top of that, I know how to upsample (smoothen) a given mesh based on loop subdivision algorithm and other subdivision algorithms. Besides, I refined my C++ coding skills and pointer manipulation skills through this project.
				</div>
				<!-- Section 1 -->
				<div class="mt-2">
					<h4> Section 1: Bezier Curves and Surfaces</h4>
				</div>
				<!-- Task 1 -->
				<div class="my-4">
					<h4> <u>Task 1 - Bezier Curves with 1D de Casteljau Subdivision</u></h4>
					<p> <b>Walk-through:</b>
						De Casteljau's algorithm calculate a Bezier curve from given control points through a recursive method. To implement it, we first connect all points from beginning points to end points to form edges. Then, we create a point to split each edge at a porpotion between 0 and 1. Thus, by connecting these new points, we get n-1 new edges from original n edges. Then we repeat this procedure until the algorithm converges to a single point. This point will lie exactly on the final Bezier curve. Now we know how to get one point on Bezier curve for a given porpotion t. If we go through every t, we will get our final Bezier curve.
					</p>
					<div class="row">
						<div class="col-6">
							<img src="assets/Bezier_Curve_Ori.png" class="mx-auto d-block w-100" alt="sample rate 9">
							<div class="text-center"> Bezier Curve Level 0</div>
						</div>
						<div class="col-6">
							<img src="assets/Bezier_Curve_Level1.png" class="mx-auto d-block w-100" alt="Q">
							<div class="text-center"> Bezier Curve Level 1</div>
						</div>
					</div>
					<div class="row">
						<div class="col-6">
							<img src="assets/Bezier_Curve_Level2.png" class="mx-auto d-block w-100" alt="sample rate 9">
							<div class="text-center"> Bezier Curve Level 2</div>
						</div>
						<div class="col-6">
							<img src="assets/Bezier_Curve_Level3.png" class="mx-auto d-block w-100" alt="Q">
							<div class="text-center"> Bezier Curve Level 3</div>
						</div>
					</div>
					<div class="row">
						<div class="col-6">
							<img src="assets/Bezier_Curve_Level4.png" class="mx-auto d-block w-100" alt="sample rate 9">
							<div class="text-center"> Bezier Curve Level 4</div>
						</div>
						<div class="col-6">
							<img src="assets/Bezier_Curve_Level5.png" class="mx-auto d-block w-100" alt="Q">
							<div class="text-center"> Bezier Curve Level 5</div>
						</div>
					</div>
					<div class="row">
						<div class="col-6">
							<img src="assets/Bezier_Curve_Final.png" class="mx-auto d-block w-100" alt="sample rate 9">
							<div class="text-center"> Bezier Curve</div>
						</div>
						<div class="col-6">
							<img src="assets/Modified_Bezier_Curve.png" class="mx-auto d-block w-100" alt="Q">
							<div class="text-center"> Modified Bezier Curve</div>
						</div>
					</div>
				</div>
				
				<!-- Task 2 -->
				<div class="my-4">
					<h4><u> Task 2 - Bezier Surfaces with Separable 1D de Casteljau</u></h4>
					<p> <b>Walk-through:</b>
						We can easily extend De Casteljau's algorithm to generate Bezier Surfaces from Bezier Curves. Essentially, Bezier Surfaces are composite of several Bezier Curves. We could first draw n Bezier Curves along one dimension (u). Then, for a given proportion t, we could get n points from n Bezier Curves. Using these n points as control points, we could draw a Bezier Curve along the other dimension (v). Similarly to how we evaluate points on Bezier Curve, if we go through every t on n Bezier Curves on dimension u, we will get our Bezier Surface that lives in uv space.
					</p>
					<div class="row">
						<div class="col-6">
							<img src="assets/Bezier_Surface.png" class="mx-auto d-block w-100" alt="sample rate 9">
							<div class="text-center"> Bezier_Surface: Teapot Mesh</div>
						</div>
						<div class="col-6">
							<img src="assets/Bezier_Surface_Shaded.png" class="mx-auto d-block w-100" alt="Q">
							<div class="text-center"> Bezier_Surface: Shaded Teapot </div>
						</div>
					</div>
				</div>

				<!-- Task 3 -->
				<div class="my-4">
					<h4><u> Task 3 - Average normals for half-edge meshes</u></h4>
					<p> <b>Walk-through:</b>
						To get a smoother normal vector of a given vertex, I iterated through all neiboring triangles (faces) of it with half-edge data structure. By averaging and normalizing the surrounding faces' normal vectors, I get the unit normal vector of a given vertex.
					</p>
					<div class="row">
						<div class="col-6">
							<img src="assets/Flat_Shading_Mesh.png" class="mx-auto d-block w-100" alt="sample rate 9">
							<div class="text-center"> Flat Shading Mesh</div>
						</div>
						<div class="col-6">
							<img src="assets/Phong_Shading_Mesh.png" class="mx-auto d-block w-100" alt="Q">
							<div class="text-center"> Phong Shading Mesh </div>
						</div>
					</div>
					<div class="row">
						<div class="col-6">
							<img src="assets/Flat_Shading.png" class="mx-auto d-block w-100" alt="sample rate 9">
							<div class="text-center"> Flat Shading</div>
						</div>
						<div class="col-6">
							<img src="assets/Phong_Shading.png" class="mx-auto d-block w-100" alt="Q">
							<div class="text-center"> Phong Shading </div>
						</div>
					</div>
				</div>

				<!-- Task 4 -->
				<div class="my-4">
					<h4><u> Task 4 - Half-Edge Flip</u></h4>
					<p> <b>Walk-through:</b>
						The half-edge flip function will flip orientations of an edge that separate two triangles. This operation only re-assigns the pointers, thus it does not involve adding or deleting mesh element. In terms of implementation details, I started by getting references of each half-edge, edge, vertex, and face, with respect to the given edge and its associated half-edge. After getting the references, I re-assign the half-edge pointers of each vertex, edge, and face. Then, for the given input edge's half-edge, I used the "setNeighbors" function to update its properties such as next, twin, vertex, edge, and face. After this operation, the given edge is "flipped". Then, I updated other half-edges with "setNeighbors" accordingly. In addition to that, I filtered out the boundary edge as it makes no sense of flipping an edge that lies on the boundary (as it does not seperate two triangles!). In terms of debugging, I double checked how I reassigned each half-edge/edge/face/vertex to make sure I did not miss something. I also found it helpful to write things down on a paper first before going through detailed pointer manipulation. In general, I did not experience a painful debugging process.
					</p>
					<div class="row">
						<div class="col-6">
							<img src="assets/Edge_Flip_Ori.png" class="mx-auto d-block w-100" alt="sample rate 9">
							<div class="text-center"> Original Edges</div>
						</div>
						<div class="col-6">
							<img src="assets/Edge_Flip_Flipped.png" class="mx-auto d-block w-100" alt="Q">
							<div class="text-center"> Flipped Edges </div>
						</div>
					</div>
				</div>

				<!-- Task 5 -->
				<div class="my-4">
					<h4><u> Task 5 - Half-Edge Split</u></h4>
					<p> <b>Walk-through:</b>
						Half-Edge splitting provides fundation of future mesh upsampling. Basically, Half-Edge splitting allows us to splitting two triangles into four triangles by inserting a point that lies on the middle of the shared edge and connecting it to the vertices. 
						<br>
						In terms of implementation, I started by getting reference of every existing half-edges, vertex, edge, and face, using the given input edge. Then, I create new half-edges,vertices, edges, and faces, because edge-split involves adding elements. This includes allocateing memory for 1 vertex, 3 edges, 2 faces, and 6 half-edges. After getting all references, I reassign the values of them, which is similiar to what I did in half-edge flip. In the original version, I filtered out the boundary edges as well. The biggest challenge here is being extremely careful when re-assigning vales of pointers as it could be easily messed by typo. Similar to what I did in Half-edge Flip, I wrote everything down on the paper and double checked my code.
					</p>
			
					<div class="row">
						<div class="col-6">
							<img src="assets/Edge_Split_Ori.png" class="mx-auto d-block w-100" alt="sample rate 9">
							<div class="text-center"> Original Edges</div>
						</div>
						<div class="col-6">
							<img src="assets/Edge_Split_Splitted.png" class="mx-auto d-block w-100" alt="Q">
							<div class="text-center"> Split Edges </div>
						</div>
					</div>
					<div class="row">
						<div class="col-3"></div>
						<div class="col-6">
							<img src="assets/Edge_Split_Combo.png" class="mx-auto d-block w-100" alt="sample rate 9">
							<div class="text-center"> Combination of Flip and Split</div>
						</div>
						<div class="col-3"></div>
					</div>
					
					<p class="mt-3"><b>Extra credit:</b>
						In this part, I altered my function to make it support boundary edges. Unlike Half-edge flip, it makes sense to split boundary edges. In  half-edge flip, we cannot flip edges because flipping involves two triangles that shared one edge. The key of flipping is to change which vertices the edge is connecting. So it doesn't make sense to flip boundary edge. However, in Half-edge split, even though there is only one triangle associated with the boundary edge, we could still find the middle point of the edge and connect it to a vertex, which will split one triangle into half. Thus, it makes sense to do half-edge split on boundary edge. 
						<br> In terms of implementation, I basically did the same thing I did to the regular edges. The difference is about how to re-assign the value for the triangle that is outside the boundary. As our program has implemented the virtual face, which is a single face that consists of polygon instead of triangle, we could be careful when assigning the "face" value of half-edges. This means that the two half-edges that are on boundary after splitted will have the same face property.
					</p>

					<div class="row">
						<div class="col-6">
							<img src="assets/Edge_Split_Bound_Ori.png" class="mx-auto d-block w-100" alt="sample rate 9">
							<div class="text-center"> Original Boundary Edges</div>
						</div>
						<div class="col-6">
							<img src="assets/Edge_Split_Bound_Splitted.png" class="mx-auto d-block w-100" alt="Q">
							<div class="text-center"> Split Boundary Edges </div>
						</div>
					</div>

				</div>



				
				<p> <b>Link to the website: </b>https://cal-cs184-student.github.io/sp22-project-webpages-o0WeiyuFeng0o/proj2/index.html</p>
			</div>
			<!-- right margin -->
			<div class="col-2 m-0 p-0"></div>
		</div>
	</div>

	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
		integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
		crossorigin="anonymous"></script>

</body>

</html>